# 스프링과 문제 해결 - 트랜잭션



## 목차

1. 문제점들
2. 트랜잭션 추상화

___



## 1. 문제점들

### 애플리케이션 구조

![애플리케이션_구조.png](./img/애플리케이션_구조.png)

- 프레젠테이션 계층
  - UI와 관련된 처리 담당
  - 웹 요청과 응답
  - 사용자 요청을 검증
  - 주 사용 기술: 서블릿과 HTTP 같은 웹 기술, 스프링 MVC
- 서비스 계층
  - 비즈니스 로직을 담당
  - 주 사용 기술: 가급적 특정 기술에 의존하지 않고 순수 자바 코드로 작성
- 데이터 접근 계층
  - 실제 데이터베이스에 접근하는 코드
  - 주 사용 기술: JDBC, JPA, File, Redis, Mongo…



### 순수 서비스 계층

- 가장 중요한 곳은 핵심 비즈니스 로직이 들어있는 서비스 계층이다.
- 시간이 흘러 UI와 데이터 저장 기술이 변경되어도, 비즈니스 로직은 최대한 변경없이 유지되어야 한다.
  - 이렇게 하려면 서비스 계층을 특정 기술에 종속적이지 않게 개발해야 한다.
  - 계층을 나눈 이유도 서비스 계층을 최대한 순수하게 유지하기 위한 목적이 크다.
- 서비스 계층이 특정 기술에 종속되지 않기 때문에 비즈니스 로직을 유지보수 하기도 쉽고, 테스트 하기도 쉽다.
- 정리하자면 서비스 계층은 가급적 비즈니스 로직만 구현하고 특정 기술에 직접 의존해서는 안된다.



### 문제점들

**MemberServiceV1**

```java
package hello.jdbc.service;

import hello.jdbc.domain.Member;
import hello.jdbc.repository.MemberRepositoryV1;
import lombok.RequiredArgsConstructor;

import java.sql.SQLException;

@RequiredArgsConstructor
public class MemberServiceV1 {

    private final MemberRepositoryV1 memberRepository;

    public void accountTransfer(String fromId, String toId, int money) throws SQLException {
        Member fromMember = memberRepository.findById(fromId);
        Member toMember = memberRepository.findById(toId);

        memberRepository.update(fromId, fromMember.getMoney() - money);
        validation(toMember);
        memberRepository.update(toId, toMember.getMoney() + money);
    }

    private void validation(Member toMember) {
        if (toMember.getMemberId().equals("ex")) {
            throw new IllegalStateException("이체중 예외 발생");
        }
    }
}
```

- MemberServiceV1은 특정 기술에 종속적이지 않고, 순수한 비즈니스 로직만 존재한다.
- 하지만 여기에도 문제가 있다.
  - SQLException이라는 JDBC 기술에 의존한다.
    - 이 부분은 `memberRepository`에서 올라오는 예외이기 때문에 `memberRepository`에서 해결해야 한다.
    - `MemberRepositoryV1`이라는 구체 클래스에 직접 의존하고 있다. `MemberRepository` 인터페이스를 도입하면 향후 `MemberService`의 코드의 변경없이 다른 구현 기술로 쉽게 변경할 수 있다.



**MemberServiceV2**

```java
package hello.jdbc.service;

import hello.jdbc.domain.Member;
import hello.jdbc.repository.MemberRepositoryV2;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import javax.sql.DataSource;
import java.sql.Connection;
import java.sql.SQLException;

/**
 * 트랜잭션 - 파라미터 연동, 풀을 고려한 종료
 */
@Slf4j
@RequiredArgsConstructor
public class MemberServiceV2 {

    private final DataSource dataSource;
    private final MemberRepositoryV2 memberRepository;

    public void accountTransfer(String fromId, String toId, int money) throws SQLException {
        Connection con = dataSource.getConnection();

        try {
            // 트랜잭션 시작
            con.setAutoCommit(false);

            bizLogic(con, fromId, toId, money);

            con.commit();
        } catch (Exception e) {
            con.rollback();
            throw new IllegalStateException(e);
        } finally {
            release(con);
        }
    }

    private void bizLogic(Connection con, String fromId, String toId, int money) throws SQLException {
        Member fromMember = memberRepository.findById(con, fromId);
        Member toMember = memberRepository.findById(con, toId);

        memberRepository.update(con, fromId, fromMember.getMoney() - money);
        validation(toMember);
        memberRepository.update(con, toId, toMember.getMoney() + money);
    }

    private void release(Connection con) {
        if (con != null) {
            try {
                con.setAutoCommit(true); // 커넥션 풀 고려해서 true 설정
                con.close();
            } catch (Exception e) {
                log.info("erro", e);
            }
        }
    }

    private void validation(Member toMember) {
        if (toMember.getMemberId().equals("ex")) {
            throw new IllegalStateException("이체중 예외 발생");
        }
    }
}
```

- 트랜잭션은 비즈니스 로직이 있는 서비스 계층에서 시작하는 것이 좋다.
- 하지만 트랜잭션을 사용하기 위해 `javax.sql.DataSource`, `java.sql.Connection`, `java.sql.SQLException` 같은 JDBC 기술에 의존해야 한다는 점이다.
  - 트랜잭션을 사용하기 위해 JDBC 기술에 의존한다. 결과적으로 비즈니스 로직보다 JDBC를 사용해서 트랜잭션을 처리하는 코드가 더 많다.
  - JPA 같은 다른 기술로 바꾸어 사용하게 되면 서비스 코드도 함께 변경해야 한다.
    - JPA는 트랜잭션을 사용하는 코드가 JDBC와 다르다.
  - 핵심 비즈니스 로직과 JDBC 기술이 섞여있어서 유지보수하기 여렵다.



### 문제 정리

- 트랜잭션 문제
  - JDBC 구현 기술이 서비스 계층에 누수되는 문제
    - 데이터 접근 계층으로 JDBC 관련 코드를 모았는데, 트랜잭션을 적용하기 위해서 JDBC 구현 기술이 서비스 계층에 누수되었다.
  - 트랜잭션 동기화 문제
    - 같은 트랜잭션을 유지하기 위해 커넥션을 파라미터로 넘겨야 한다.
    - 이때 파생되는 문제는 똑같은 기능도 트랜잭션용 기능과 비트랜잭션용 기능을 분리해야 한다.
  - 트랜잭션 적용 반복 문제
    - 트랜잭션 적용 코드를 보면 반복이 많다. `try`, `catch`, `finally` …
- 예외 누수 문제
  - 데이터 접근 계층의 JDBC 구현 기술 예외가 서비스 계층으로 전파된다.
    - `SQLException`은 체크 예외이기 때문에 데이터 접근 계층을 호출한 서비스 계층에서 해당 예외를 잡아서 치리하거나 명시적으로 `throws`를 통해서 다시 던져야 한다.
    - `SQLException`은 JDBC 전용 기술이다. JPA나 다른 데이터 접근 기술을 사용하면, 그에 맞는 다른 예외로 변경해야 하고, 결국 서비스 코드도 수정해야 한다.
- JDBC 반복 문제
  - 지금까지 작성한 MemberRepository 코드는 순수한 JDBC를 사용했다.
  - 이 코드들은 유사한 코드의 반복이 너무 많다.
    - `try`, `catch`, `finally` …
    - 커넥션을 열고, `PreparedStatement`를 사용하고, 결과를 매핑하고, 실행하고, 커넥션과 리소스를 정리한다.



## 2. 트랜잭션 추상화

- 현재 서비스 계층은 트랜잭션을 사용하기 위해서 JDBC 기술에 의존하고 있다.
- 구현 기술에 따른 트랜잭션 사용법
  - JDBC: `con.setAutoCommit(false)`
  - JPA: `transaction.begin()`
- 따라서 JDBC 기술을 사용하다가 JPA 기술로 변경하게 되면 서비스 계층의 코드도 JPA 기술을 사용하도록 수정해야 한다.

### 트랜잭션 추상화 인터페이스

- 이 문제를 해결하려면 트랜잭션 기능을 추상화하면 된다.
- **트랜잭션 추상화 인터페이스**

```java
public interface TxManager {
	void begin();
	void commit();
	void rollback();
}
```

- 그리고 다음과 같이  `TxManager` 인터페이스를 기반으로 각각의 기술에 맞는 구현체를 만들면 된다.

![트랜잭션_추상화와_의존관계.png](./img/트랜잭션_추상화와_의존관계.png)

- 클라이언트인 서비스는 인터페이스에 의존하고 DI를 사용한 덕분에 OCP 원칙을 지키게 되었다.
  - 이제 트랜잭션을 사용하는 서비스 코드를 전혀 변경하지 않고, 트랜잭션 기술을 마음껏 변경할 수 있다.



### 스프링의 트랜잭션 추상화

- 스프링은 이미 이러한 문제를 해결해두었다.
- 데이터 접근 기술에 따른 트랜잭션 구현제도 대부분 만들어 두어서 가져다 사용하기만 하면 된다.

![스프링_트랜잭션_추상화.png](./img/스프링_트랜잭션_추상화.png)

- 스프링 트랜잭션 추상화의 핵심은 `org.springframework.transaction.PlatformTransactionManager` 인터페이스이다.

```java
package org.springframework.transaction;

public interface PlatformTransactionManager extends TransactionManager {

		TransactionStatus getTransaction(@Nullable TransactionDefinition definition)
				throws TransactionException;

		void commit(TransactionStatus status) throws TransactionException;

		void rollback(TransactionStatus status) throws TransactionException;
}
```

- `getTransaction()`: 트랜잭션을 시작한다.
  - 기존에 이미 진행중인 트랜잭션이 있는 경우 해당 트랜잭션에 참여할 수 있다.
  - 트랜잭션 참여, 전파에 대한 부분은 뒤에서 설명한다.
- `commit()`: 트랜잭션을 커밋한다.
- `rollback()`: 트랜잭션을 롤백한다.